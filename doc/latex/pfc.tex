\documentclass[10pt, a4paper]{report}

\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{spverbatim}
\usepackage{multirow}
\usepackage[left=3.5cm,right=1.5cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage{listings}
\usepackage{hyperref}
\author{Daniel Fernández Villanueva}
\title{Sistema de monitorización inercial del movimiento de las extremidades superiores}

\makeatletter
\renewcommand*{\UTFviii@defined}[1]{%
  \ifx#1\relax
    \begingroup
      % Remove prefix "\u8:"
      \def\x##1:{}%
      % Extract Unicode char from command name
      % (utf8.def does not support surrogates)
      \edef\x{\expandafter\x\string#1}%
      \StringEncodingConvert\x\x{utf8}{utf16be}% convert to UTF-16BE
      % Hexadecimal representation
      \EdefEscapeHex\x\x
      % Enhanced error message
      \PackageError{inputenc}{Unicode\space char\space \string#1\space
                              (U+\x)\MessageBreak
                              not\space set\space up\space
                              for\space use\space with\space LaTeX}\@eha
    \endgroup
  \else\expandafter
    #1%
  \fi
}
\makeatother

\setcounter{tocdepth}{3}
\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{frame=tb,
  language=C++,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  frame=single,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true
  tabsize=4
}

\begin{document}

\maketitle

\tableofcontents

\listoftables

%%% ================ PARTE 1 : MEMORIA ================ %%%

\part{Memoria}

\pagestyle{headings}


%% ******** Capítulo 1 ******** %%

\chapter{ANTECEDENTES}


%% ******** Capítulo 2 ******** %%

\chapter{OBJETIVO DEL PROYECTO}

Este proyecto tiene como objetivo la implementación de un sistema de monitorización en tiempo real del movimiento de las extremidades superiores del cuerpo humano. Para la realización de este sistema se tendrá que dar solución a los siguientes

\begin{enumerate}
\item \textbf{Aplicación para la adquisición de datos de los sensores inerciales}: \\
Realización de un sistema que permitirá obtener en tiempo real los datos que proporcionan los sensores. En concreto se desarrollará un driver para un sensor xsens o una red de sensores xsens conectados mediante un master xbus. Este driver permitirá leer los datos que proporcionan los acelerómetros, giróscopos, magnetómetros y sensores de temperatura, además de la orientación de cada uno de los sensores conectados al PC. Este driver se encargará también de crear una interfaz para la posterior utilización de los datos en otros programas de foma sencilla. \\

\item \textbf{Tratamiento de los datos para obtener los ángulos de rotación entre cada sensor}:\\
Una vez sea posible la adquisición de los datos con el driver anterior, se creará otro programa con el que se obtendrán los ángulos de rotación entre cada sensor teniendo en cuenta además la geometría de las articulaciones del brazo o modelo sobre las que se situarán los sensores.\\

\item \textbf{Utilización de los datos para el objetivo deseado}: \\
En esta última fase se crearán los sistemas necesarios para la utilización de los datos con el objetivo deseado:

\begin{itemize}

\item Para la visualización de la posición del brazo en el simulador 3D Gazebo, se creará un modelo del brazo y una interfaz etre ROS y el simulador que permitirá la visualización de la posición del brazo en tiempo real.  

\item Para el control del robot mediante el movimiento del brazo o modelo del robot físico, se creará otra interfaz entre ROS y el driver del propio robot. 

\end{itemize}

\end{enumerate}


%%% ******** Capítulo 3 ******** %%%
\chapter{ESPECIFICACIONES DE DISEÑO}



%%% ******** Capítulo 4 ******** %%%
\chapter{DISEÑO DEL SISTEMA}

\section{Estudio de soluciones}
\section{Simulación}

%%% ******** Capítulo 3 ******** %%%
\chapter{IMPLEMENTACIÓN FÍSICA}
\section{Selección de componentes}
\section{Montaje}
\section{Ajuste}

\chapter{PROTOCOLO DE PRUEBAS. REDISEÑO}

\chapter{RESULTADOS OBTENIDOS}
%%% ******** Capítulo 5 ******** %%%
\chapter{HERRAMIENTAS UTILIZADAS}

En este capítulo se realizará una breve descripción de los elementos utilizados en el proyecto, tanto de hardware como de software.

\section{Hardware}

\subsection{Sensores XSENS}

\subsubsection{Sensor MTi-G}

\subsubsection{XBUS Master}

\subsection{Brazo humano}

\subsection{Robot Youbot}

\subsection{Modelo del robot Youbot}

\section{Software}

\subsection{ROS}

\subsubsection{¿Qué es ROS?}

ROS (del inglés \textit{Robot Operating System} - Sistema Operativo Robótico) es una plataforma de desarrollo de software que incluye conjunto de utilidades centradas en ayudar al desarrollador en la creación de programas para el control de robots. Esta herramienta incorpora abstracción del hardware, drivers para dispositivos, librerías, visualizadores, utilidades para el intercambio de mensajes entre programas y administradores de paquetes de software, entre otras muchas cosas. ROS es además software abierto, bajo una licencia BSD, por lo que cualquier persona puede ver su código fuente y modificarlo.

\subsubsection{¿Por qué usar ROS?}

ROS proporciona solución a diversos problemas que vienen dados inherentemente al objetivo de este proyecto:

\begin{itemize}

\item \textbf{Creación y compilación de programas}

\begin{itemize}

\item \textbf{Gestor de paquetes}

\end{itemize}

\item \textbf{Comunicación entre programas:}
ROS incluye:

\begin{itemize}

\item \textbf{Máster}

\item \textbf{Topics}

\item \textbf{Servicios}

\item \textbf{Servidor de parámetros}

\end{itemize}

\item \textbf{Visualización de datos}

\item \textbf{Otras herramientas}

\begin{itemize}

\item \textbf{Bag}

\item \textbf{rxplot}

\end{itemize}


\end{itemize}

\subsection{El sistema operativo Ubuntu}

\subsubsection{¿Qué es Ubuntu?}

Ubuntu es un sistema operativo con núcleo Linux. Es gratuito y es distribuido como software \textit{open source}. Se trata de la distribución GNU/Linux más popular en equipos personales

\subsubsection{¿Por qué usar Ubuntu?}

\subsection{El lenguaje de programación C++}



\subsection{Simulador Gazebo}

Gazebo es programa para simulación en 3D de un robot o una población de robots interactuando entre sí y el ambiente. Incorpora simulación de la física de sólidos rígidos y de la respuesta de sensores. Además incorpora un visualizador 3D bastante potente que permite ver en tiempo real la posición de los robots de forma realista.\\

La versión de Gazebo que se va a utilizar proporciona también una serie de herramientas para la comunicación con ROS. 
 

\subsection{Visualizador RViz}

\subsection{Control de versiones: git}

%%% ******** Capítulo 4 ******** %%%

\chapter{PROCESO DE REALIZACIÓN}

En este capítulo se detallará el proceso de realización de cada una de las fases del proyecto.

\section{Creación del driver para la adquisición de datos de los sensores xsens}

En está primera fase se tratará de encontrar un método para la toma de datos de la red de sensores inerciales. Estos sensores estarán conectados a un máster, que irá conectado al PC mediante conexión USB. Los datos así obtenidos se publicarán en \textit{topics} de ROS.

\subsubsection{Método seguido}

Para la realización del driver se ha partido del código incluido en la documentación de los sensores

\subsection{El paquete xsens\_driver}



\section{Creación de una librería matemática en C++ que permita trabajar con posiciones y orientaciones}


\subsection{La librería dfv}

\subsubsection{La clase Quaternion}

\subsubsection{La clase Vector3}

\subsubsection{La clase Matrix}

\section{Cálculo de los ángulos formados entre cada sensor}

\subsection{Formas de representar orientaciones espaciales}

Se puede configurar el sensor xsens para que proporcione una de las siguientes representaciones de su orientación:

\begin{itemize}

\item Ángulos de Euler.
\item Matriz de rotación.
\item Cuaternión. 

\end{itemize}

\subsubsection{Ángulos de Euler}

Los ángulos de Euler son tres ángulos introducidos por Leonhard Euler para describir la orientación de un sólido rígido o de un sistema de referencia respecto a otro. Representan una secuencia de tres rotaciones elementales alrededor de los ejes de un sistema de coordenadas. Cualquier orientación puede describirse como la composición de tres rotaciones elementales, que pueden suceder alrededor de los ejes de un sistema de referencia fijo (rotaciones extrínsecas) o alrededor de los ejes de un sistema solidario al sólido rígido (rotaciones intrínsecas), lo que se denomina un sistema de referencia local. \\

Existen multitud de maneras distintas de expresar los ángulos de Euler, dependiendo del orden de los ejes sobre los cuales se realizan las rotaciones, y de si el sistema de referencia es local o global. La definición usada por los sensores xsens es la composición de rotaciones alrededor de los ejes XYZ en ese orden y un sistema de referencia global (fijo a la Tierra), en el que la ausencia de rotación equivale al vector Z paralelo a la línea que une la posición del sensor con el centro de la Tierra y sentido ascendente, y el vector X en dirección al norte magnético. \\

Los ángulos proporcionados por el sensor son:

\begin{itemize}

\item $\phi$ = \textit{roll} = rotación alrededor del eje X $[-\frac{\pi}{2}, \frac{\pi}{2}]$

\item $\theta$ = \textit{pitch} = rotación alrededor del eje Y $[-\frac{\pi}{4}, \frac{\pi}{4}]$

\item $\psi$ = \textit{yaw} = rotación alrededor del eje Z $[-\frac{\pi}{2}, \frac{\pi}{2}]$

\end{itemize}

El uso de ángulos de Euler presenta un par de problemas:

\begin{itemize}

\item Si $\theta$ se extiende al intervalo $[-\frac{\pi}{2}, \frac{\pi}{2}]$ en vez de restringirse a $[-\frac{\pi}{4}, \frac{\pi}{4}]$, la descripción de la rotación no es única. En este caso existen dos posibles soluciones para cada orientación, por lo que los datos que proporciona el sensor no son suficientes para diferenciar entre un estado de rotación u otro.

\item Cuando $\theta$ se acerca al valor $\pm\frac{\pi}{4}$ existe una singularidad matemática causada por la infinitud de valores que pueden adquirir $\phi$ y $\psi$ en dicho caso. Esta situación es la que se conoce con el nombre de \textit{gimbal lock}.

\end{itemize}

Estos problemas no están presentes en los demás modos de salida del sensor.

\subsubsection{Matriz de rotación}

Una matriz de rotación es una matriz usada para expresar una rotación en un espacio euclideo. Si se supone un sistema generador $S$ con un conjunto de vectores base $B$ del espacio vectorial $V$:

$$ B = \{\vec{i}, \vec{j}, \vec{k}\}, \quad \vec{i} = \left( \begin{smallmatrix} 1\\0\\0 \end{smallmatrix} \right) \quad  \vec{j} = \left( \begin{smallmatrix} 0\\1\\0 \end{smallmatrix} \right) \quad  \vec{k} = \left( \begin{smallmatrix} 0\\0\\1 \end{smallmatrix} \right)$$
$$ V = S(\vec{i}, \vec{j}, \vec{k}) $$

Se somete al sistema de coordenadas a una rotación $R$. Los vectores base sufren una transformación que se puede expresar con respecto al sistema de referencia original de la siguiente forma:

$$ \vec{i}' = \alpha_{11}\vec{i} + \alpha_{21}\vec{j} + \alpha_{31}\vec{k} = \left( \begin{smallmatrix}  \alpha_{11}\\\alpha_{21}\\\alpha_{31} \end{smallmatrix} \right)$$
$$ \vec{j}' = \alpha_{12}\vec{i} + \alpha_{22}\vec{j} + \alpha_{32}\vec{k} = \left( \begin{smallmatrix} \alpha_{12}\\\alpha_{22}\\\alpha_{32} \end{smallmatrix} \right)$$
$$ \vec{k}' = \alpha_{13}\vec{i} + \alpha_{23}\vec{j} + \alpha_{33}\vec{k} = \left( \begin{smallmatrix} \alpha_{13}\\\alpha_{23}\\\alpha_{33} \end{smallmatrix} \right)$$

donde $\alpha_{ij}$ son las componentes de la base rotada expresadas con respecto a la base original. Se tiene un vector cualquiera en la base original:

$$ \vec{v} = a\vec{i} + b\vec{j} + c\vec{k} = \left( \begin{smallmatrix} a\\b\\c \end{smallmatrix} \right)$$

Tras la rotación las componentes del vector expresadas conforme a la nueva base no variarán debido a que se mueve solidario al sistema de referencia. Por lo tanto el vector rotado es el siguiente:

$$ \vec{v}' = a\vec{i}' + b\vec{j}' + c\vec{k}' $$

Sustituyendo los vectores $\vec{i}'$, $\vec{j}'$, $\vec{k}'$ por sus expresiones respecto a la base original:

$$ \vec{v}' = a\left( \begin{smallmatrix}  \alpha_{11}\\\alpha_{21}\\\alpha_{31} \end{smallmatrix} \right) + b\left( \begin{smallmatrix}  \alpha_{12}\\\alpha_{22}\\\alpha_{32} \end{smallmatrix} \right) + c\left( \begin{smallmatrix}  \alpha_{13}\\\alpha_{23}\\\alpha_{33} \end{smallmatrix} \right) = \left( \begin{smallmatrix}  a\alpha_{11} + b\alpha_{12} + c\alpha_{13} \\ a\alpha_{21} + b\alpha_{22} + c\alpha_{23}\\ a\alpha_{31} + b\alpha_{32} + c\alpha_{33} \end{smallmatrix} \right)$$

Este nuevo vector puede expresarse como el producto de una matriz por un vector:

$$ \vec{v}' = \left( \begin{smallmatrix}  \alpha_{11} & \alpha_{12} & \alpha_{13} \\ \alpha_{21} & \alpha_{22} & \alpha_{23}\\ \alpha_{31} & \alpha_{32} & \alpha_{33} \end{smallmatrix} \right) \left( \begin{smallmatrix} a \\ b \\ c \end{smallmatrix} \right) = R \vec{v}$$

Dicha matriz $R$ es la denominada matriz de rotación. Se comprueba que puede interpretarse como una matriz cuyos elementos son las componentes de los vectores base del sistema de coordenadas rotado expresados con respecto al sistema de coordenadas original.\\

El uso de matrices de rotación evita los problemas que presentan los ángulos de Euler; Proporcionan una descripción biunívoca del estado de rotación del sensor, y además no presentan el problema del \textit{gimbal lock}. 

\subsubsection{Cuaternión}

Los cuaterniones son una extensión de los números complejos ideada por el matemático irlandés William Rowand Hamilton con el objetivo de poder utilizar el análisis complejo en un espacio de 3 dimensiones.Un cuaternión es la combinación lineal de cuatro cantidades \{$1$, $i$, $j$, $k$\}, donde cada una de las cantidades \{$i$, $j$, $k$\} es la raíz cuadrada de $-1$, de tal forma que se cumplen las siguientes propiedades:

$$ i^2 = j^2 = k^2 = ijk = -1 $$

La expresión general de un cuaternión es la siguiente:

$$ q = w + xi + yj + zk $$

donde $w$, $x$, $y$ y $z$ son números reales. Los cuaterniones satisfacen las leyes conmutativa y asociativa de la suma, la ley asociativa de la multiplicación, las leyes distributivas de la multiplicación respecto a la suma y la existencia de los elementos neutros para la suma y la multiplicación:

\begin{table}[h]
\center
\begin{tabular}{|l|c|}

\hline
\multicolumn{2}{|c|}{\textbf{Propiedades de los cuaterniones}}\\
\hline
Conmutativa respecto a la suma & $ q_1 + q_2 = q_2 + q_1 $ \\
\hline
Asociativa respecto a la suma & $ q_1 + (q_2 + q_3) = (q_1 + q_2) + q_3 $ \\
\hline
Asociativa respecto a la multiplicación & $ q_1(q_2q_3) = (q_1q_2)q_3 $ \\
\hline
\multirow{2}{*}{Distributiva de la multiplicación respecto a la suma} & $ q_1(q_2 + q_3) = q_1q_2 + q_1q_3 $ \\
\cline{2-2}
 & $ (q_1 + q_2)q_3 = q_1q_3 + q_2q_3 $ \\
\hline
Elemento neutro de la suma & $ q + 0 = q $ \\
\hline
Elemento neutro de la multiplicación & $ q1 = 1q = q $ \\
\hline

\end{tabular}

\caption{Propiedades de los cuaterniones}
\label{tab:propiedades_cuaterniones}

\end{table}

Los cuaterniones presentan las mismas ventajas que las matrices de rotación, pero además son más estables numéricamente y más eficientes en términos computacionales.

\subsection{Utilización de cuaterniones para la representación de rotaciones de un sólido rígido}

Sea un vector unitario:

\begin{equation}
\vec{e} = e_x i + e_y j + e_z k, \quad \|e\| = \sqrt{e_x^2 + e_y^2 + e_z^2} = 1
\end{equation}


Se definirá el cuaternión de rotación con ángulo $\theta$ sobre el eje dado por el vector $\vec{e}$:

\begin{equation}
q(\theta, \vec{e}) = \cos \left(\frac{\theta}{2}\right) + \sin \left(\frac{\theta}{2}\right) e_x i + \sin \left(\frac{\theta}{2}\right) e_y j + \sin \left(\frac{\theta}{2}\right) e_z k 
\end{equation}

Se puede descomponer el cuaternión como suma de un número real y un cuaternión imaginario puro multiplicado por otro número real:

\begin{equation}
q( \theta , \vec{e}) = \cos \left(\frac{\theta}{2}\right) + \sin \left(\frac{\theta}{2}\right) e  
\end{equation}

Donde $e$ es el cuaternión imaginario puro (parte real nula) cuyas componentes se corresponden a las del vector unitario $\vec{e}$ que define el eje de rotación.\\

Por cuestión de comodidad definimos las siguientes variables:

\begin{equation}
c_i = \cos \left( \frac{\theta_i}{2} \right)
\end{equation}
\begin{equation}
s_i = \sin \left( \frac{\theta_i}{2} \right)
\end{equation}

De tal forma que ahora el cuaternión se escribirá de la siguiente manera:

\begin{equation}
q(\theta_i, \vec{e_i}) = c_i + s_i e_i
\end{equation}

El producto de dos cuaterniones se puede expresar de esta forma:

\begin{equation}
q_1 q_2 = \left( c_1 + s_1 e_1 \right) \left( c_2 + s_2 e_2 \right) = c_1 c_2 + c_1 s_2 e_2 + c_2 s_1 e_1 + s_1 s_2 e_1 e_2
\end{equation}

En donde:

\begin{multline}
e_1 e_2 = (e_{1_x} i + e_{1_y} j + e_{1_z} k)(e_{2_x} i + e_{2_y} j + e_{2_z} k) = \\
= e_{1_x} i (e_{2_x} i + e_{2_y} j + e_{2_z} k) + e_{1_y} j (e_{2_x} i + e_{2_y} j + e_{2_z} k) + e_{1_z} k (e_{2_x} i + e_{2_y} j + e_{2_z} k) = \\
= -(e_{1_x} e_{2_x} + e_{1_y} e_{2_y} + e_{1_z} e_{2_z}) + i (e_{1_y} e_{2_z} + e_{1_z} e_{2_y}) + j (-e_{1_x} e_{2_z} + e_{1_z} e_{2_x}) + k (e_{1_x} e_{2_y} + e_{1_y} e_{2_x}) \\
\end{multline}

\begin{equation} \label{eq: e_1e_2}
e_1 e_2 =  -e_1 \cdot e_2 + e_1 \times e_2
\end{equation}

Por lo tanto:

\begin{equation}
q_1 q_2 = c_1 c_2 + c_1 s_2 e_2 + c_2 s_1 e_1 + s_1 s_2 (-e_1 \cdot e_2 + e_1 \times e_2)
\end{equation}

\begin{equation}
q_1 q_2 = c_1 c_2 - s_1 s_2 (e_1 \cdot e_2) + c_1 s_2 e_2 + c_2 s_1 e_1 + s_1 s_2 (e_1 \times e_2)
\end{equation}

El conjugado del cuaternión $ q = c + s e $ se representará de la siguiente manera:

\begin{equation}
conj(q) = q^* = c - s e
\end{equation}

Dado a que se va a trabajar siempre con cuaterniones unitarios (también llamados \textit{versores}), se podrá asumir lo siguiente:

\begin{equation}
\|q\| = 1 , \quad q^{-1} = \frac{q^*}{\|q\|^2} = q^*
\end{equation}

De tal forma que:

\begin{equation}
qq^* = q^*q = 1
\end{equation}

\subsubsection{Rotación de un vector alrededor de un eje y un ángulo dados}

Se puede realizar la rotación de un vector alrededor de un eje $\vec{e}$ y un ángulo $\theta$ mediante la siguiente operación:

\begin{equation}
p' = q_1pq_1^*, \quad q_1 = q(\theta_1, \vec{e_1})
\end{equation}

Si multiplicamos a la izquierda por $q_1^*$ y por la derecha por $q_1$:

\begin{equation}
q_1^*p'q_1 = q_1^*(q_1pq_1)q_1^*
\end{equation}

\begin{equation}
q_1^*p'q_1 = p
\end{equation}

Se obtiene que el conjugado representa una rotación inversa a la del cuaternión original:

\begin{equation}
q^* = q\left(\theta, -\vec{e} \right) = q\left(-\theta, \vec{e}\right)
\end{equation}

\subsubsection{Composición de rotaciones en coordenadas extrínsecas}

El cuaternión de rotación definido por $q\left(\theta, \vec{e}\right)$ representa una rotación alrededor de un eje $\vec{e}$ fijo al sistema de referencia global.\\

Realizando una nueva rotación al vector obtenido anteriormente, se obtendrá una rotación compuesta por una primera rotación definida por el cuaternión $q_1$ seguida de otra rotación definida por $q_2$:

\begin{equation}
p'' = q_2p'q_2^*, \quad q_2 = q(\theta_2, \vec{e_2})
\end{equation}

\begin{equation}
p'' = q_2(q_1pq_1^*)q_2^* = (q_2q_1)p(q_1^*q_2^*) = q_{12}pq_{12}^*
\end{equation}

Se puede expresar la composición de dos rotaciones como un nuevo cuaternión que resulta de la multiplicación en orden inverso de los cuaterniones que definen las dos rotaciones:

\begin{equation}
q_{12} = q_2 q_1
\end{equation}

De aquí se obtiene que el conjugado del producto de dos cuaterniones es el producto de los conjugados en orden inverso:

\begin{equation}
q_{12} = \left(q_2q_1\right)^* = q_1^*q_2^*
\end{equation}

De forma análoga, para $n$ cuaterniones:

\begin{equation}
q_{12 \dotsc (n-1)n} = q_nq_{n-1} \dotsm q_2q_1
\end{equation}

\begin{equation}
\left( q_{12 \dotsc (n-1)n} \right)^* = \left( q_nq_{n-1} \dotsm q_2q_1 \right)^* = q_1^*q_2^* \dotsm q_{n-1}^*q_n^*
\end{equation}

\subsubsection{Composición de rotaciones en coordenadas intrínsecas}



\subsubsection{Relación entre rotaciones intrínsecas y extrínsecas}

A continuación se demostrará que una rotación compuesta por varias rotaciones en el sistema de coordenadas intrínseco del sólido rígido se corresponde a la composición de rotaciones en el sistema extrínseco realizadas en orden inverso.\\

Se define un cuaternión de rotación asociado al eje intrínseco $\vec{e_2}$ después de haber sufrido una rotación definida por el cuaternión $q_1 = q\left( \theta_1 , \vec{e_1} \right)$ como:

\begin{equation}
q_{2}^I = q\left(\theta_2 , \vec{e_2}^I \right) , \quad \vec{e_2}^I = (q_1e_2q_1^*)_{\vec{v}}
\end{equation}

La orientación de partida es la misma para el sistema intrínseco y el extrínseco, por lo tanto:

\begin{equation}
q_1^E = q_1^I = q_1
\end{equation}

Para demostrar la afirmación de partida se tendrá que demostrar la veracidad de la siguiente igualdad:

\begin{equation}
q_2^Iq_1 = q_1q_2^E
\end{equation}

Se reordenará la igualdad para que los cálculos sean más sencillos:

\begin{equation} \label{eq: E01}
q_2^Iq_1 = q_1q_2^E \iff q_2^I = q_1q_2^Eq_1^*
\end{equation}

Desarrollo del lado izquierdo de la igualdad:

\begin{equation} \label{eq: q_2I}
q_2^I = c_2 + s_2(q_1e_2q_1^*)
\end{equation}

\begin{multline} \label{eq: q_1e_2q_1}
q_1e_2q_1^* = (c_1 + s_1e_1)e_2(c_1 - s_1e_1) = (c_1e_2 + s_1e_1e_2)(c_1 - s_1e_1) = \\
= c_1^2e_2 + s_1c_1e_1e_2 - c_1s_1e_2e_1 - s_1^2e_1e_2e_1 = c_1^2e_2 + s_1c_1(e_1e_2 - e_2e_1) - s_1^2e_1e_2e_1
\end{multline}

De \eqref{eq: e_1e_2} se tiene lo siguiente:

$$ e_1e_2 = -e_1 \cdot e_2 + e_1 \times e_2 $$
$$ e_2e_1 = -e_2 \cdot e_1 + e_2 \times e_1 = -e_1 \cdot e_2 - e_1 \times e_2 $$

\begin{equation} \label{eq: e_1e_2}
e_1 e_2 - e_2 e_1 = 2(e_1 \times e_2)
\end{equation}

$$ e_1 e_2 e_1 = (-e_1 \cdot e_2 + e_1 \times e_2)e_1 =(-e_1 \cdot e_2)e_1 + (e_1 \times e_2)e_1 $$

De esta ecuación:

$$ (e_1 \times e_2)e_1 = -(e_1 \times e_2) \cdot e1 + (e_1 \times e_2) \times e_1 $$

$(e_1 \times e_2)$ será un vector perpendicular a $e_1$, por lo que $(e_1 \times e_2) \cdot e_1 = 0$:

$$ (e_1 \times e_2)e_1 = (e_1 \times e_2) \times e_1 $$

Por lo tanto:

\begin{equation} \label{eq: e_1e_2e_1}
e_1 e_2 e_1 = -(e_1 \cdot e_2)e_1 + (e_1 \times e_2) \times e_1
\end{equation}

Sustituyendo en \eqref{eq: q_1e_2q_1}:

$$ q_1e_2q_1^* = c_1^2e_2 + s_1c_1(e_1e_2 - e_2e_1) - s_1^2e_1e_2e_1 = $$
$$ c_1^2e_2 + 2s_1c_1(e_1 \times e_2) - s_1^2(-(e_1 \cdot e_2)e_1 + (e_1 \times e_2) \times e_1) $$

\begin{equation}
q_1e_2q_1^* = c_1^2e_2 + 2s_1c_1(e_1 \times e_2) + s_1^2(e_1 \cdot e_2)e_1 - s_1^2(e_1 \times e_2) \times e_1
\end{equation}

Finalmente, sustituyendo en \eqref{eq: q_2I}:

$$ q_2^I = c_2 + s_2(c_1^2e_2 + 2s_1c_1(e_1 \times e_2) + s_1^2(e_1 \cdot e_2)e_1 - s_1^2(e_1 \times e_2) \times e_1) $$

\begin{equation} \label{eq: E02}
q_2^I = c_2 + s_2c_1^2e_2 + 2s_1s_2c_1(e_1 \times e_2) + s_1^2s_2(e_1 \cdot e_2)e_1 - s_1^2s_2(e_1 \times e_2) \times e_1
\end{equation}

Ahora se procederá a desarrollar el lado derecho de la igualdad \eqref{eq: E01}:

$$ q_1q_2^Eq_1^* = (c_1 + s_1 e_1)(c_2 + s_2 e_2)(c_1 - s_1 e_1) = $$

$$ = (c_1c_2 + s_2c_1e_2 + s_1c_2e_1 + s_1s_2e_1e_2)(c_1 - s_1 e_1) = $$

$$ = c_1^2c_2 + s_2c_1^2e_2 + s_1c_1c_2e_1 + s_1s_2c_1e_1e_2 - s_1c_1c_2e_1 - s_1s_2c_1e_2e_1 - s_1^2c_2e_1e_1 - s_1^2s_2e_1e_2e_1  = $$

Como $\|e_1\| = 1$, se tendrá que:

\begin{equation}
e_1e_1 = -e_1 \cdot e_1 + e_1 \times e_1 = -1
\end{equation}

Sustituyendo y reorganizando:

$$ q_1q_2^Eq_1^* = c_2 + s_2c_1^2e_2 + s_1s_2c_1(e_1e_2 - e_2e_1) - s_1^2s_2e_1e_2e_1 $$

De \eqref{eq: e_1e_2} y \eqref{eq: e_1e_2e_1}:

$$ q_1q_2^Eq_1^* = c_2 + s_2c_1^2e_2 + 2s_1s_2c_1(e_1 \times e_2) - s_1^2s_2(-(e_1 \cdot e_2)e_1 + (e_1 \times e_2) \times e_1) $$

\begin{equation} \label{eq: E03}
q_1q_2^Eq_1^* = c_2 + s_2c_1^2e_2 + 2s_1s_2c_1(e_1 \times e_2) + s_1^2s_2(e_1 \cdot e_2)e_1 - s_1^2s_2(e_1 \times e_2) \times e_1
\end{equation}

Finalmente se compara \eqref{eq: E02} con \eqref{eq: E03}:

$$ q_2^I = c_2 + s_2c_1^2e_2 + 2s_1s_2c_1(e_1 \times e_2) + s_1^2s_2(e_1 \cdot e_2)e_1 - s_1^2s_2(e_1 \times e_2) \times e_1 $$

$$ q_1q_2^Eq_1^* = c_2 + s_2c_1^2e_2 + 2s_1s_2c_1(e_1 \times e_2) + s_1^2s_2(e_1 \cdot e_2)e_1 - s_1^2s_2(e_1 \times e_2) \times e_1 $$

Se tiene que:

$$ q_2^I = q_1q_2^Eq_1^* $$

Y por lo tanto es verdad que:

\begin{equation}
q_2^Iq_1 = q_1q_2^E
\end{equation}

\subsubsection{Orientación relativa entre dos sólidos}

\section{Incorporación de las herramientas creadas}

\subsection{Visualizador de la posición del brazo}

\subsubsection{Obtención de los ángulos de rotación entre cada segmento del brazo}

\subsubsection{Cálculo de las posiciones de cada segmento del brazo}

\subsubsection{Implementación}

\subsection{Controlador de un simulador del brazo robótico del robot Youbot}

\subsection{Controlador del brazo robótico del robot Youbot real}

%%% ******** Capítulo 5 ******** %%%

\chapter{RESULTADOS EXPERIMENTALES}


%%% ******** Capítulo 6 ******** %%%

\chapter{CONCLUSIONES}


%%% ******** Capítulo 7 ******** %%%

\chapter{BIBLIOGRAFÍA}


%%% ================ PARTE 2 : ANEXOS ================ %%%

\part{Anexos}

\appendix

\chapter{INSTALACIÓN Y PUESTA EN MARCHA DEL SOFTWARE}

\chapter{SOLUCIÓN DE PROBLEMAS}

\section{Error iniciando Gazebo}

\begin{spverbatim}
Msg Waiting for master
Msg Connected to gazebo master @ http://localhost:11345
Exception [Master.cc:69] Unable to start server[Address already in use]


terminate called after throwing an instance of 'gazebo::common::Exception'
Aborted (core dumped)
[gazebo-1] process has died [pid 2795, exit code 134, cmd /opt/ros/fuerte/stacks/simulator_gazebo/gazebo/scripts/gazebo /opt/ros/fuerte/stacks/simulator_gazebo/gazebo_worlds/worlds/empty.world __name:=gazebo __log:=/home/daniel/.ros/log/772c2f96-ab75-11e2-a2fc-001de05009b5/gazebo-1.log].
log file: /home/daniel/.ros/log/772c2f96-ab75-11e2-a2fc-001de05009b5/gazebo-1*.log
LightListWidget::OnLightMsg
\end{spverbatim}

\textbf{Solución: }
Ejecutar comando:
\begin{verbatim}
$ ps ax | grep [g]z
\end{verbatim}

Ver si hay un proceso gzserver

\begin{spverbatim}
 3118 ?        Sl    12:47
 /opt/ros/fuerte/stacks/simulator_gazebo/gazebo/gazebo/bin/gzserver 
 /opt/ros/fuerte/stacks/simulator_gazebo/gazebo_worlds/worlds/empty.world __name:=gazebo __log:=/home/daniel/.ros/log/8188cc76-ab73-11e2-a4ec-001de05009b5/gazebo-1.log -s /opt/ros/fuerte/stacks/simulator_gazebo/gazebo/lib/libgazebo_ros_paths_plugin.so -s /opt/ros/fuerte/stacks/simulator_gazebo/gazebo/lib/libgazebo_ros_api_plugin.so
\end{spverbatim}

Si lo hay, ejecutar \textit{System Monitor} y matar el proceso \textit{gzserver}.

\chapter{Instalación y configuración del software necesario}

\section{Instalación de ROS Fuerte}

La versión de ROS que se utilizará es ROS Fuerte. Esta elección se debe a que dicha versión es compatible con el simulador Gazebo, con el que posteriormente se realizará la visualización en 3D del modelo.\\

Para realizar la instalación de ROS  se partirá de una instalación previa de Ubuntu, pudiendo ser éste de cualquiera de estas \textit{releases}:

\begin{itemize}
\item 10.04 LTS (Lucid Lynx)
\item 11.04 (Oneiric Ocelot)
\item 12.04 LTS (Precise Pangolin)
\end{itemize}

\subsection{Configuración de los repositorios de Ubuntu}

Se procederá a abrir el Centro de Sofware de Ubuntu y en la barra de menú de dicho programa, se seleccionará en el menú Edit la opción Software Sources. En la pestaña Ubuntu Software se comprobará que están seleccionados los repositorios restricted, universe y multiverse:\\

%\includegraphics[scale=0.5]{../img/Software sources.png} 

\subsection{Configuración del archivo sources.list}

El archivo sorces.list le dice al gestor de paquetes de Ubuntu de dónde puede obtener cada paquete de ROS.
Se abrirá un terminal y se ejecutará el siguiente comando que dependerá de la versión de Ubuntu que tengamos instalada:\\

\textbf{Ubuntu 10.04 (Lucid)}
\begin{verbatim}
$ sudo sh -c 'echo "deb http://packages.ros.org/ros/ubuntu lucid main" 
> /etc/apt/sources.list.d/ros-latest.list'
\end{verbatim}

\textbf{Ubuntu 11.10 (Oneiric)}
\begin{verbatim}
$ sudo sh -c 'echo "deb http://packages.ros.org/ros/ubuntu oneiric main" 
> /etc/apt/sources.list.d/ros-latest.list'
\end{verbatim}

\textbf{Ubuntu 12.04 (Precise)}
\begin{verbatim}
$ sudo sh -c 'echo "deb http://packages.ros.org/ros/ubuntu precise main" 
> /etc/apt/sources.list.d/ros-latest.list'
\end{verbatim}

Este comando lo que hace es crear un archivo de texto en la ruta especificada como parámetro, que contiene la dirección de donde descargar los paquetes para la versión específica de ROS que tengamos.

\subsection{Configuración de la keys}

En el terminal se ejecutará el siguiente comando:

\begin{verbatim}
$ wget http://packages.ros.org/ros.key -O - | sudo apt-key add -
\end{verbatim}

\subsection{Descarga e instalación}

Se actualizará el índice de paquetes de Ubuntu para tener la seguridad de que el servidor de ROS.org está indexado:

\begin{verbatim}
$ sudo apt-get update
\end{verbatim}

A continuación se procederá a descargar e instalar la versión completa de ROS. El el terminal se ejecutará el siguiente comando:

\begin{verbatim}
$ sudo apt-get install ros-fuerte-desktop-full
\end{verbatim}

Esta instalación traerá consigo las siguientes herramientas, entre otras:

\begin{itemize}
\item ROS
\item rx (herramientas para interfaz gráfica: rxbag,  rxgraph, rxplot, ...)
\item rviz (herramienta de visualización 3D)
\item librerías genéricas para robots
\item Simuladores 2D/3D (entre ellos Gazebo)
\item Navegación y percepción 2D y 3D
\end{itemize}

\subsection{Configuración del entorno}

Cada vez que se inicie un nuevo terminal es necesario añadir las variables de entorno. Si se quisiera, se puede automatizar dicha tarea ejecutando el comando:

\begin{verbatim}
$ echo “source /opt/ros/fuerte/setup.bash” >> ~/.bashrc
\end{verbatim}

Este comando añade la línea  source /opt/ros/fuerte/setup.bash al archivo ~/.bashrc. Este archivo contiene la configuración inicial del terminal, y se ejecuta cada vez que abrimos un nuevo terminal. Posteriormente se ejecutará el archivo anterior para actualizar el terminal. De esta forma reconocerá los nuevos comandos de ROS:

\begin{verbatim}
$ . ~/.bashrc
\end{verbatim}

\subsection{Otras herramientas}

Se instalarán dos herramientas que permitirán obtener los paquetes necesarios para obtener los datos de los sensores XSENS MTi-G. Para ello, en el terminal se ejecutará el siguiente comando:

\begin{verbatim}
$ sudo apt-get install python-rosinstall python-rosdep
\end{verbatim}

\section{Instalación del simulador Gazebo}

Para instalar la versión de Gazebo preparada para comunicarse con ROS se ejecutará el siguiente comando:

\begin{verbatim}
$ sudo apt-get install ros-fuerte-simulator-gazebo
\end{verbatim}


\chapter{CÓDIGO FUENTE}

\section{Driver Xsens}

\subsection{xsens\_node.cpp}
%\lstinputlisting[language=C++]{../../xsens_driver/src/xsens_node.cpp}
\newpage

\part{Otros documentos}

\section{Manual del sensor MTi-G}

%\includepdf[pages={-}]{doc/mtig_manual.pdf}
AAAAAAAAAAAAAAAAAAAAAAa

\end{document}
